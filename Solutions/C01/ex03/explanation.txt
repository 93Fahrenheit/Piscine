════════════════════════════════════════════════════════════════════════════════════════════
🔷 DANS LE MAIN : déclarations, appels et usage des variables
════════════════════════════════════════════════════════════════════════════════════════════

╔═══════════════════════════════════════╦════════════╦══════════════════════════════════════════════════════════╗
║ Expression                            ║ Type       ║ Rôle / Signification                                     ║
╠═══════════════════════════════════════╬════════════╬══════════════════════════════════════════════════════════╣
║ res_div                               ║ int        ║ Stocke le résultat de la division                        ║
║ res_mod                               ║ int        ║ Stocke le reste (modulo) de la division                  ║
║ &res_div                              ║ int *      ║ Adresse mémoire de res_div, transmise à la fonction      ║
║ &res_mod                              ║ int *      ║ Adresse mémoire de res_mod, transmise à la fonction      ║
║ ft_div_mod(a, b, &res_div, &res_mod); ║ void       ║ Appel de fonction avec valeurs et adresses à modifier    ║
║ printf("%d\n", res_div);              ║ affichage  ║ Affiche la valeur entière de res_div                     ║
║ printf("%d\n", res_mod);              ║ affichage  ║ Affiche la valeur entière de res_mod                     ║
╚═══════════════════════════════════════╩════════════╩══════════════════════════════════════════════════════════╝


════════════════════════════════════════════════════════════════════════════════════════════
🔷 DANS LA FONCTION : réception des pointeurs et manipulation
════════════════════════════════════════════════════════════════════════════════════════════

╔═══════════════════════════════════════╦════════════╦══════════════════════════════════════════════════════════╗
║ Expression                            ║ Type       ║ Rôle / Signification                                     ║
╠═══════════════════════════════════════╬════════════╬══════════════════════════════════════════════════════════╣
║ int *div                              ║ int *      ║ Pointeur vers un int : contient l'adresse de res_div     ║
║ int *mod                              ║ int *      ║ Pointeur vers un int : contient l'adresse de res_mod     ║
║ *div                                  ║ int        ║ Accède à la valeur pointée = res_div                     ║
║ *mod                                  ║ int        ║ Accède à la valeur pointée = res_mod                     ║
║ *div = a / b;                         ║ affectation║ Stocke le quotient dans res_div via le pointeur          ║
║ *mod = a % b;                         ║ affectation║ Stocke le reste dans res_mod via le pointeur             ║
╚═══════════════════════════════════════╩════════════╩══════════════════════════════════════════════════════════╝

════════════════════════════════════════════════════════════════════════════════════════════
🔴 ATTENTION : ERREUR CLASSIQUE SUR L’UTILISATION DES POINTEURS
════════════════════════════════════════════════════════════════════════════════════════════

╔══════════════════════════════════════╦════════════════════════════════════════════════════════════════════════════════╗
║ Mauvaise pratique                    ║ int *ptr; = 42 OU int *ptr; *ptr = 42;                                     	║
║ 🔴 Problème                          ║ ptr n’a pas été initialisé. Il pointe vers n’importe où → segfault probable 	║
╠══════════════════════════════════════╬═════════════════════════════════════════════════════════════════════════════	╣
║ Bonne pratique                       ║ int var = 0; int *ptr = &var; *ptr = 42;                                    	║
║ ✅ Pourquoi c’est correct            ║ ptr pointe vers une vraie adresse valide (celle de var)                     	║
╚══════════════════════════════════════╩════════════════════════════════════════════════════════════════════════════════╝

→ On ne peut pas initialiser un pointeur et placer une valeur à l'adresse mémoire pointée en même temps 
