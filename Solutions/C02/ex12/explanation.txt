--------------------------------------------
Conversion d'un type de variable à un autre
--------------------------------------------

Lorsqu'on veut travailler avec un pointeur void * il faut caster la variable pour pouvoir acceder à son contenu . Pour caster on doit le faire sous cette forme :
nouveau_type nouveau_nom_variable = (nouveau_type) nom_variable_initiale
ex : pour caster void *addr en unsigned long on fait
unsigned long nb = (unsigned long) addr;

------------------------------------------------------
Tableaux, pointeurs et indexation avec l’opérateur []
------------------------------------------------------

Un tableau de données, que ce soit un char ou un int contient des éléments stockés à la suite les un des autres en mémoire (dans la stack ou dans la heap si une allocation à été faite, par exemple avec malloc) 

Un tableau en C est en réalité un pointeur vers son premier élément.

On peut faire un déplacement d’adresse ou un offset avec : 
str + i  = donne directement un pointeur vers l'élément de str situé à l'indice i ou il va se déplacer de i valeur. C’est la même chose que &str[i]. On obtient donc l’adresse de l’élément à l’index i. 

Déréférencer un pointeur = accéder la valeur stockée à l’adresse pointée par ce pointeur 

L’opérateur [] permet d’indexer un tableau ou d’acceder à un caractère spécifique dans la chaine. 

str[I] ou int[i] permet d’accéder au i-ème élément de la chaine en fonction de la valeur de i. On peut aussi écrire *(str + i), c’est la même chose 

A retenir 
str + i == &str[I] 
*(str + I) == str[I] 

-------------------------------------
Convertir une adresse en hexadécimal 
-------------------------------------

Une adresse est stocké comme un nombre binaire dans la mémoire. Pour la convertir en hexadécimal il faut convertir les bits par 4 en chiffre hexadécimal en partant des bits les plus faibles (donc tout à droite). 

—> chaque 4 bits représente une valeur qui peut être exprimée en un seul chiffre hexadécimal 0 à 15 et de 0000 à 1111 en binaire

Ex : pour n = 10101111 (en binaire), qui correspond à 175 en décimal, cela donne af en hexadécimal 
1010 (en binaire) → A (en hexadécimal)
1111 (en binaire) → F (en hexadécimal)

175%16 = 15 = F (dernier chiffre)
175/16 = 10 
10%16 = 10 —> A (premier chiffre) 

Plus en détail : 
175 / 16 =  10 —> A
10 x 16 = 160
175 - 160 =  15 —> F 
  Pour récupérer les derniers 4 bits de poids faibles on divise par 16 le nombre binaire et on récupère le reste, c’est à dire qu’on fait nb % 16, et on convertit ce chiffre en hexadécimal grâce à la chaine "0123456789abcdef" et on l’ajoute à la nouvelle chaine qui représente l’adresse en hexadécimal (hexa_addr). 


Ex: si nb%16 = 3, le chiffre en hexadécimal sera 3
      si nb%16 = 11, le chiffre en hexadécimal sera b 

Ensuite il faut mettre à jour nb en faisant nb/16, ce qui déplacera les 4 derniers bits à droite (ce qui les fait sortir donc en réduisant le nombre) pour traiter les 4 prochains bits tout à droite. 

Pour comprendre : 
En binaire pur, diviser par 2 revient à décaler d’un bit vers la droite.
Donc diviser par 16 (= 2⁴) revient à décaler de 4 bits vers la droite.

Ex pour n = 10101111 
n%16 = 1111 (en binaire) soit 15 (en décimal) et f (en hexadécimal) 
n/16 (en décimal) = 10101111 / 10000 (en binaire) = 00001010

On construit le nombre hexadécimal depuis le dernier chiffre donc de la droite vers la gauche pour qu’ils soient dans le bon ordre dans la nouvelle chaine (hexa_addr) et on décremente l’index à chaque itération pour passer au chiffre de gauche. Forcément on commence à l’index de la fin de la chaine, on la construit donc à partir de la fin. 

La nouvelle chaine qui sera l’adresse en hexadécimal doit avoir 16 caractères donc on commence à i = 15
—> sur un OS 64 bits, étant donné que 1 chiffre en hexadécimal = 4 bits, 
64 bits / 4 bits = 16 chiffres hexadécimaux pour traiter toutes les combinaisons possibles
Donc, si on veut remplir ce tableau de droite à gauche, on commence à i = 15 et on décrémente jusqu’à 0 pour traiter tout le nombre. 

